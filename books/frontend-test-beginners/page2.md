---
title: 'そもそもテストとは'
---

# そもそもテストとは

みなさんはフロントエンドのテストを書いていますか。そもそもテスト書く意義について、安全かつ正確にリリースされることを目指すために必要だと考えています。とある機能をリリースする際に、その機能が正しく動作していることを担保する必要があります。

## テストの種類

下記 4 種類が存在します。

- 静的解析
- ユニットテスト
- 結合テスト
- E2E (End to End) テスト

### 静的解析

主に [ESLint](https://eslint.org/) や [Stylelint](https://stylelint.io/) などを利用した静的解析を始め、さらに [TypeScript](https://www.typescriptlang.org/) などを利用した静的型チェックも挙げられます。

また Node.js 環境下で動作を検証できる [textlint](https://textlint.github.io/) も存在し、機械的に文章を校正してくれます。

#### 静的解析の種類

- JavaScript のお作法と合っているか機械的に検証してくれる [ESLint](https://eslint.org/)
- CSS のお作法と合っているか機械的に検証してくれる [Stylelint](https://stylelint.io/)
- HTML 標準と合っているか機械的に検証してくれる [markuplint](https://markuplint.dev/)
- 機械的に文章を校正してくれる [textlint](https://textlint.github.io/)

### ユニットテスト

[Jest](https://jestjs.io/) や [Mocha](https://mochajs.org/) などを利用したユニットテストを始め、最小単位の関数やコンポーネントを対象にテストを書きます。

npm trends で見てもらっても明らかだが、最近は [Jest](https://jestjs.io) を採用しているプロジェクトは多い。

- [npm trends - `jasmine` vs `jest` vs `mocha`](https://www.npmtrends.com/jest-vs-mocha-vs-jasmine)
- [npm trends - `jasmine` vs `jest` vs `mocha` vs `vitest`](https://npmtrends.com/jasmine-vs-jest-vs-mocha-vs-vitest)

#### ユニットテストの種類

下記に示すように 4 つのユニットテストが存在します。

- [Jest](https://jestjs.io/)
- [Vitest](https://vitest.dev/)
- [Mocha](https://mochajs.org/)
- [Jasmine](https://jasmine.github.io/)

今回の Zenn book 執筆にあたって Mocha と Jasmine を割愛させていただきます。以下簡単な説明ではございますが Mocha と Jasmine の概要に触れさせていただきました。

Mocha は Node.js 上で動作する JavaScript のテストフレームワークです。基本的に Jest と同じく Mocha はアサーションやモックのために [Enzyme](https://enzymejs.github.io/enzyme/) など他のライブラリと組み合わせることができます。

:::message

Enzyme は [React](https://ja.reactjs.org/) 専用に設計されているライブラリで、シャローレンダリングとマウントテストの 2 種類のテスト方法を提供している。

:::

Mocha の利点に以下のようなものが挙げられる一方、他のライブラリをインポートする必要があります。

- Web ブラウザのサポートが存在する
- 非同期のテストを書ける
- アサーションライブラリを使用できる

Jasmine は Web ブラウザと Node.js のためのシンプルな JavaScript のテストフレームワークです。原則として動作駆動型の開発パターンに従っているため、一般的には使用前に設定が行われます。

Jasmine の利点に以下のようなものが挙げられる一方、完璧なテストフレームワークとは言えない現状があります。スナップショットテストにサポートしていないこと、並列化やネイティヴ DOM を操作するためにサードパーティライブラリを必要とすることが挙げられるためです。

- テストに DOM を必要としない
- フロントエンドとバックエンドのテストに採用できる
- 非同期関数のテストを書ける
- 多種多様なアサーションを使用できる
  - 等値チェッカーアサーション
  - マッチャーアサーション

### 結合テスト

技術スタックに React を採用している場合で [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/) や Enzyme などを利用して、コンポーネントや hooks を組み合わせて正しく動作するかテストを書きます。

なお、この Enzyme は React 専用に設計されており、子コンポーネントを持たないユニットとしてのコンポーネントのテストに役立つシャローレンダリングと、マウントテストの 2 種類のテスト方法を提供しています。

出力されたものを操作・トラバースしたり、ある意味ではランタイムをシミュレートできたりするライブラリです。コンポーネントのレンダリング、要素の検索、要素とのインタラクションを支援しています。

### E2E (End to End) テスト

Web ブラウザ上でユーザーと同じユースケースを想定して、システム全体を対象にテストを書きます。

#### E2E テストの種類

- [Cypress](https://www.cypress.io/)

## テストトロフィーという考え方

React Testing Library の開発者のひとり Kent C. Dodds 氏が提唱するテストトロフィーです。

https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications

各種テストが階層化されており、それぞれの階層について以下の特徴を持っている。

- 上の階層に行くほど、実装コストは高い
- 上の階層に行くほど、実行時間は長い
- 上の階層に行くほど、信頼性は高い

上の階層に位置する E2E テストは Web ブラウザやサーバーを起動するため、他のテストと比較すると実装コストが高くなり非常に実行時間が長くなります。また E2E テストがカバーする領域は非常に広く実際のユーザーシナリオ上でテストは実行されるため、その信頼性は高くなる反面、エラーが発生したときの原因特定に時間がかかったりテスト結果も不安定になります。

一方、下の階層に位置するユニットテストは、単一の関数やコンポーネントを対象にテストを書くことが多い。テストが失敗した際にデバッグがしやすかったりテスト結果のフィードバック速度が早いのでイテレーションを回しやすい反面、単一の関数やコンポーネントを対象にテストを書くからこそそれらを組み合わせたときに正しく動作する保証はありません。

## 新たに登場しているテスト

下記 1 種類が存在します。

- ビジュアルリグレッションテスト

### ビジュアルリグレッションテスト

ビジュアルリグレッションテスト (以降 VRT と呼ぶ) が挙げられ、テストトロフィーの階層にたとえるとユニットテストと結合テストに所属することとなります。

Storybook に代表されるカタログツールを導入すると、各コンポーネントを単体でレンダリングする環境が整っているため、あとは VRT 用にスクリーンショットを撮影してプルリクエスト (Pull Request) 上で比較する開発スタイルを取り入れることができます。

また Storybook の開発元が提供する VRT の SaaS で Chromatic が存在します。

https://www.chromatic.com/

Storybook のストーリーでスクリーンショットを撮影して、プルリクエスト (Pull Request) 上で差分を検出できます。

## テスト戦略

全てのテストに言えることとして導入を後回しにすると、いずれの導入コストも跳ね上がる点には注意したい。

その上で基本的な戦略としては、各々のプロジェクトで相談していただきたいが、戦略のベースラインとしては下記に示す形で問題無いものと考えています。

- 静的テストは必須
- ユニットテストは独自で作成した関数やコンポーネントに対してのみ必ず書く
- 結合テストは難しい
  - 外部 API と連携する hooks など、何かしらのドメイン (ビジネスロジック) が注入される箇所を中心に必ず書く
- E2E テストは不具合発生の要因になりうる箇所を中心に書く

筆者は結合テストについて、特にどういった場面で書いていけば良いか、説明するには大変難しいと考えています。とはいえ何かしらの結論を述べさせていただくと、外部 API と連携する hooks など、何かしらのドメイン (ビジネスロジック) が注入される箇所を中心にテストを書けば良いのではと考えています。

こういった依存性の集中する箇所を重点的に検証することで、アプリ全体が安全かつ正確に動作することを担保してくれるでしょう。実際にそれは結合テストの対象として問題無いか、ドメイン (ビジネスロジック) をモジュール・コンポーネントの外へ切り出してユニットテストの対象としてテストを実施した方が良いのでは無いか、などと自問自答できるようになっていると良さそうです。

私の場合は、複雑な責務を絡めない程度にドメイン (ビジネスロジック) を外へ切り出せるなら、極力切り出すことを試します。ユニットテストを基本的に書きながら、時たま結合テストも書くことで抜け漏れの無いテストが開発側で完結させられるメリットを享受できます。

最後に念を押してこれだけは、基本的に各プロジェクトのメンバー間で必ずテストの方針については相談してください。
